var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CoolTensors","category":"page"},{"location":"#CoolTensors","page":"Home","title":"CoolTensors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CoolTensors]","category":"page"},{"location":"#CoolTensors.CoolTensors","page":"Home","title":"CoolTensors.CoolTensors","text":"CoolTensors\n\nThe easiest way to create Tensor objects is using IndexPos objects. They can easily created with the custom T\"...\" string literal. ' denotes contravariant indices and , covariant indices:\n\njulia> x = T\"'\"[√2, 1]\n2-element Tensor{Float64,1,T\"'\",Array{Float64,1}}:\n 1.4142135623730951\n 1.0\n\njulia> Λ(ψ) = T\"',\"[cosh(ψ) -sinh(ψ); -sinh(ψ) cosh(ψ)]\nΛ (generic function with 1 method)\n\njulia> using LinearAlgebra\n\njulia> g = T\",,\"(Diagonal([1, -1]))\n2×2 Tensor{Int64,2,T\",,\",Diagonal{Int64,Array{Int64,1}}}:\n 1   0\n 0  -1\n\nlower and raise lower and raise indices: (The metric is assumed to be euclidian.)\n\njulia> lower(x, 1)\n2-element Tensor{Float64,1,T\",\",Array{Float64,1}}:\n 1.4142135623730951\n 1.0\n\njulia> 𝔤 = raise(g, 1, 2)\n2×2 Tensor{Int64,2,T\"''\",Diagonal{Int64,Array{Int64,1}}}:\n 1   0\n 0  -1\n\nIndexing can be done just like a regular array, using TIndex, which stores an additional IndexPos in the type parameter, or by using hvcat syntax. When using the latter, indices are separated by either whitespace or ;, ; switches the contra-/covariance of the following indices, whitespace means an index has the same contra-/covariance as the last index. To specify that the first index is covariant, write \\; before the first index.\n\njulia> x[1]\n1.4142135623730951\n\njulia> lower(x, 1)[\\; 1]\n1.4142135623730951\n\njulia> Λ(.5)[1; 2]\n-0.5210953054937474\n\njulia> g[\\; 2 2]\n-1\n\njulia> g[1; 2]\nERROR: ArgumentError: Index positions T\"',\" don't match indices of Tensor T\",,\"\nStacktrace:\n[...]\n\nTensors can be called with vectors and covectors. The rightmost index is always contracted first. If called with multiple (co-)vectors, the first (co-)vector is contracted with the last index of the tensor, the second with the second-last index, and so on. : can be used to skip the contraction of an index.\n\njulia> Λ(.5)(x)\n2-element Tensor{Float64,1,T\"'\",Array{Float64,1}}:\n 1.073608627785168\n 0.3906859168881719\n\njulia> Λ(.5)(lower(x, 1))\nERROR: ArgumentError: Tensor indices don't match\nStacktrace:\n[...]\n\njulia> Λ(.5)(:, lower(x, 1))\n2-element Tensor{Float64,1,T\",\",Array{Float64,1}}:\n 1.073608627785168\n 0.3906859168881719\n\njulia> lower(x, 1)(x)\n3.0000000000000004\n\nLet's prove that g(x, x) is Lorentz invariant!\n\njulia> g(x, x)\n1.0000000000000004\n\njulia> g(Λ(.5)(x), Λ(.5)(x))\n0.9999999999999998\n\nQED.\n\n⊗ (\\otimes) from TensorCore.jl is overloaded and exported to calculate the tensor product of two Tensors:\n\njulia> x ⊗ lower(x, 1)\n2×2 Tensor{Float64,2,T\"',\",Array{Float64,2}}:\n 2.0      1.41421\n 1.41421  1.0\n\nDisclaimer: This is currently only a prototype. It is still missing a lot of features. Performance should be pretty bad. There will be bugs. Don't use this for any productive work.\n\n\n\n\n\n","category":"module"}]
}
